// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/firestore/v1/firestore.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The request for [Firestore.GetDocument][google.firestore.v1.Firestore.GetDocument].
public struct Google_Firestore_V1_GetDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the Document to get. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  public var name: String = String()

  /// The fields to return. If not set, returns all fields.
  ///
  /// If the document has a field that is not present in this mask, that field
  /// will not be returned in the response.
  public var mask: Google_Firestore_V1_DocumentMask {
    get {return _mask ?? Google_Firestore_V1_DocumentMask()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public var consistencySelector: Google_Firestore_V1_GetDocumentRequest.OneOf_ConsistencySelector? = nil

  /// Reads the document in a transaction.
  public var transaction: Data {
    get {
      if case .transaction(let v)? = consistencySelector {return v}
      return Data()
    }
    set {consistencySelector = .transaction(newValue)}
  }

  /// Reads the version of the document at the given time.
  /// This may not be older than 60 seconds.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = consistencySelector {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {consistencySelector = .readTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public enum OneOf_ConsistencySelector: Equatable {
    /// Reads the document in a transaction.
    case transaction(Data)
    /// Reads the version of the document at the given time.
    /// This may not be older than 60 seconds.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_GetDocumentRequest.OneOf_ConsistencySelector, rhs: Google_Firestore_V1_GetDocumentRequest.OneOf_ConsistencySelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _mask: Google_Firestore_V1_DocumentMask? = nil
}

/// The request for [Firestore.ListDocuments][google.firestore.v1.Firestore.ListDocuments].
public struct Google_Firestore_V1_ListDocumentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent resource name. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents` or
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  /// For example:
  /// `projects/my-project/databases/my-database/documents` or
  /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
  public var parent: String = String()

  /// The collection ID, relative to `parent`, to list. For example: `chatrooms`
  /// or `messages`.
  public var collectionID: String = String()

  /// The maximum number of documents to return.
  public var pageSize: Int32 = 0

  /// The `next_page_token` value returned from a previous List request, if any.
  public var pageToken: String = String()

  /// The order to sort results by. For example: `priority desc, name`.
  public var orderBy: String = String()

  /// The fields to return. If not set, returns all fields.
  ///
  /// If a document has a field that is not present in this mask, that field
  /// will not be returned in the response.
  public var mask: Google_Firestore_V1_DocumentMask {
    get {return _mask ?? Google_Firestore_V1_DocumentMask()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public var consistencySelector: Google_Firestore_V1_ListDocumentsRequest.OneOf_ConsistencySelector? = nil

  /// Reads documents in a transaction.
  public var transaction: Data {
    get {
      if case .transaction(let v)? = consistencySelector {return v}
      return Data()
    }
    set {consistencySelector = .transaction(newValue)}
  }

  /// Reads documents as they were at the given time.
  /// This may not be older than 60 seconds.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = consistencySelector {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {consistencySelector = .readTime(newValue)}
  }

  /// If the list should show missing documents. A missing document is a
  /// document that does not exist but has sub-documents. These documents will
  /// be returned with a key but will not have fields, [Document.create_time][google.firestore.v1.Document.create_time],
  /// or [Document.update_time][google.firestore.v1.Document.update_time] set.
  ///
  /// Requests with `show_missing` may not specify `where` or
  /// `order_by`.
  public var showMissing: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public enum OneOf_ConsistencySelector: Equatable {
    /// Reads documents in a transaction.
    case transaction(Data)
    /// Reads documents as they were at the given time.
    /// This may not be older than 60 seconds.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_ListDocumentsRequest.OneOf_ConsistencySelector, rhs: Google_Firestore_V1_ListDocumentsRequest.OneOf_ConsistencySelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _mask: Google_Firestore_V1_DocumentMask? = nil
}

/// The response for [Firestore.ListDocuments][google.firestore.v1.Firestore.ListDocuments].
public struct Google_Firestore_V1_ListDocumentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Documents found.
  public var documents: [Google_Firestore_V1_Document] = []

  /// The next page token.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [Firestore.CreateDocument][google.firestore.v1.Firestore.CreateDocument].
public struct Google_Firestore_V1_CreateDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent resource. For example:
  /// `projects/{project_id}/databases/{database_id}/documents` or
  /// `projects/{project_id}/databases/{database_id}/documents/chatrooms/{chatroom_id}`
  public var parent: String = String()

  /// The collection ID, relative to `parent`, to list. For example: `chatrooms`.
  public var collectionID: String = String()

  /// The client-assigned document ID to use for this document.
  ///
  /// Optional. If not specified, an ID will be assigned by the service.
  public var documentID: String = String()

  /// The document to create. `name` must not be set.
  public var document: Google_Firestore_V1_Document {
    get {return _document ?? Google_Firestore_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  /// The fields to return. If not set, returns all fields.
  ///
  /// If the document has a field that is not present in this mask, that field
  /// will not be returned in the response.
  public var mask: Google_Firestore_V1_DocumentMask {
    get {return _mask ?? Google_Firestore_V1_DocumentMask()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _document: Google_Firestore_V1_Document? = nil
  fileprivate var _mask: Google_Firestore_V1_DocumentMask? = nil
}

/// The request for [Firestore.UpdateDocument][google.firestore.v1.Firestore.UpdateDocument].
public struct Google_Firestore_V1_UpdateDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The updated document.
  /// Creates the document if it does not already exist.
  public var document: Google_Firestore_V1_Document {
    get {return _document ?? Google_Firestore_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  /// The fields to update.
  /// None of the field paths in the mask may contain a reserved name.
  ///
  /// If the document exists on the server and has fields not referenced in the
  /// mask, they are left unchanged.
  /// Fields referenced in the mask, but not present in the input document, are
  /// deleted from the document on the server.
  public var updateMask: Google_Firestore_V1_DocumentMask {
    get {return _updateMask ?? Google_Firestore_V1_DocumentMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// The fields to return. If not set, returns all fields.
  ///
  /// If the document has a field that is not present in this mask, that field
  /// will not be returned in the response.
  public var mask: Google_Firestore_V1_DocumentMask {
    get {return _mask ?? Google_Firestore_V1_DocumentMask()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  /// An optional precondition on the document.
  /// The request will fail if this is set and not met by the target document.
  public var currentDocument: Google_Firestore_V1_Precondition {
    get {return _currentDocument ?? Google_Firestore_V1_Precondition()}
    set {_currentDocument = newValue}
  }
  /// Returns true if `currentDocument` has been explicitly set.
  public var hasCurrentDocument: Bool {return self._currentDocument != nil}
  /// Clears the value of `currentDocument`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentDocument() {self._currentDocument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _document: Google_Firestore_V1_Document? = nil
  fileprivate var _updateMask: Google_Firestore_V1_DocumentMask? = nil
  fileprivate var _mask: Google_Firestore_V1_DocumentMask? = nil
  fileprivate var _currentDocument: Google_Firestore_V1_Precondition? = nil
}

/// The request for [Firestore.DeleteDocument][google.firestore.v1.Firestore.DeleteDocument].
public struct Google_Firestore_V1_DeleteDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the Document to delete. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  public var name: String = String()

  /// An optional precondition on the document.
  /// The request will fail if this is set and not met by the target document.
  public var currentDocument: Google_Firestore_V1_Precondition {
    get {return _currentDocument ?? Google_Firestore_V1_Precondition()}
    set {_currentDocument = newValue}
  }
  /// Returns true if `currentDocument` has been explicitly set.
  public var hasCurrentDocument: Bool {return self._currentDocument != nil}
  /// Clears the value of `currentDocument`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentDocument() {self._currentDocument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _currentDocument: Google_Firestore_V1_Precondition? = nil
}

/// The request for [Firestore.BatchGetDocuments][google.firestore.v1.Firestore.BatchGetDocuments].
public struct Google_Firestore_V1_BatchGetDocumentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  public var database: String = String()

  /// The names of the documents to retrieve. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  /// The request will fail if any of the document is not a child resource of the
  /// given `database`. Duplicate names will be elided.
  public var documents: [String] = []

  /// The fields to return. If not set, returns all fields.
  ///
  /// If a document has a field that is not present in this mask, that field will
  /// not be returned in the response.
  public var mask: Google_Firestore_V1_DocumentMask {
    get {return _mask ?? Google_Firestore_V1_DocumentMask()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public var consistencySelector: Google_Firestore_V1_BatchGetDocumentsRequest.OneOf_ConsistencySelector? = nil

  /// Reads documents in a transaction.
  public var transaction: Data {
    get {
      if case .transaction(let v)? = consistencySelector {return v}
      return Data()
    }
    set {consistencySelector = .transaction(newValue)}
  }

  /// Starts a new transaction and reads the documents.
  /// Defaults to a read-only transaction.
  /// The new transaction ID will be returned as the first response in the
  /// stream.
  public var newTransaction: Google_Firestore_V1_TransactionOptions {
    get {
      if case .newTransaction(let v)? = consistencySelector {return v}
      return Google_Firestore_V1_TransactionOptions()
    }
    set {consistencySelector = .newTransaction(newValue)}
  }

  /// Reads documents as they were at the given time.
  /// This may not be older than 60 seconds.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = consistencySelector {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {consistencySelector = .readTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public enum OneOf_ConsistencySelector: Equatable {
    /// Reads documents in a transaction.
    case transaction(Data)
    /// Starts a new transaction and reads the documents.
    /// Defaults to a read-only transaction.
    /// The new transaction ID will be returned as the first response in the
    /// stream.
    case newTransaction(Google_Firestore_V1_TransactionOptions)
    /// Reads documents as they were at the given time.
    /// This may not be older than 60 seconds.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_BatchGetDocumentsRequest.OneOf_ConsistencySelector, rhs: Google_Firestore_V1_BatchGetDocumentsRequest.OneOf_ConsistencySelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.newTransaction, .newTransaction): return {
        guard case .newTransaction(let l) = lhs, case .newTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _mask: Google_Firestore_V1_DocumentMask? = nil
}

/// The streamed response for [Firestore.BatchGetDocuments][google.firestore.v1.Firestore.BatchGetDocuments].
public struct Google_Firestore_V1_BatchGetDocumentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A single result.
  /// This can be empty if the server is just returning a transaction.
  public var result: Google_Firestore_V1_BatchGetDocumentsResponse.OneOf_Result? = nil

  /// A document that was requested.
  public var found: Google_Firestore_V1_Document {
    get {
      if case .found(let v)? = result {return v}
      return Google_Firestore_V1_Document()
    }
    set {result = .found(newValue)}
  }

  /// A document name that was requested but does not exist. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  public var missing: String {
    get {
      if case .missing(let v)? = result {return v}
      return String()
    }
    set {result = .missing(newValue)}
  }

  /// The transaction that was started as part of this request.
  /// Will only be set in the first response, and only if
  /// [BatchGetDocumentsRequest.new_transaction][google.firestore.v1.BatchGetDocumentsRequest.new_transaction] was set in the request.
  public var transaction: Data = Data()

  /// The time at which the document was read.
  /// This may be monotically increasing, in this case the previous documents in
  /// the result stream are guaranteed not to have changed between their
  /// read_time and this one.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single result.
  /// This can be empty if the server is just returning a transaction.
  public enum OneOf_Result: Equatable {
    /// A document that was requested.
    case found(Google_Firestore_V1_Document)
    /// A document name that was requested but does not exist. In the format:
    /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
    case missing(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_BatchGetDocumentsResponse.OneOf_Result, rhs: Google_Firestore_V1_BatchGetDocumentsResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for [Firestore.BeginTransaction][google.firestore.v1.Firestore.BeginTransaction].
public struct Google_Firestore_V1_BeginTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  public var database: String = String()

  /// The options for the transaction.
  /// Defaults to a read-write transaction.
  public var options: Google_Firestore_V1_TransactionOptions {
    get {return _options ?? Google_Firestore_V1_TransactionOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: Google_Firestore_V1_TransactionOptions? = nil
}

/// The response for [Firestore.BeginTransaction][google.firestore.v1.Firestore.BeginTransaction].
public struct Google_Firestore_V1_BeginTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction that was started.
  public var transaction: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [Firestore.Commit][google.firestore.v1.Firestore.Commit].
public struct Google_Firestore_V1_CommitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  public var database: String = String()

  /// The writes to apply.
  ///
  /// Always executed atomically and in order.
  public var writes: [Google_Firestore_V1_Write] = []

  /// If set, applies all writes in this transaction, and commits it.
  public var transaction: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [Firestore.Commit][google.firestore.v1.Firestore.Commit].
public struct Google_Firestore_V1_CommitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The result of applying the writes.
  ///
  /// This i-th write result corresponds to the i-th write in the
  /// request.
  public var writeResults: [Google_Firestore_V1_WriteResult] = []

  /// The time at which the commit occurred.
  public var commitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _commitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_commitTime = newValue}
  }
  /// Returns true if `commitTime` has been explicitly set.
  public var hasCommitTime: Bool {return self._commitTime != nil}
  /// Clears the value of `commitTime`. Subsequent reads from it will return its default value.
  public mutating func clearCommitTime() {self._commitTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for [Firestore.Rollback][google.firestore.v1.Firestore.Rollback].
public struct Google_Firestore_V1_RollbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  public var database: String = String()

  /// The transaction to roll back.
  public var transaction: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [Firestore.RunQuery][google.firestore.v1.Firestore.RunQuery].
public struct Google_Firestore_V1_RunQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent resource name. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents` or
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  /// For example:
  /// `projects/my-project/databases/my-database/documents` or
  /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
  public var parent: String = String()

  /// The query to run.
  public var queryType: Google_Firestore_V1_RunQueryRequest.OneOf_QueryType? = nil

  /// A structured query.
  public var structuredQuery: Google_Firestore_V1_StructuredQuery {
    get {
      if case .structuredQuery(let v)? = queryType {return v}
      return Google_Firestore_V1_StructuredQuery()
    }
    set {queryType = .structuredQuery(newValue)}
  }

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public var consistencySelector: Google_Firestore_V1_RunQueryRequest.OneOf_ConsistencySelector? = nil

  /// Reads documents in a transaction.
  public var transaction: Data {
    get {
      if case .transaction(let v)? = consistencySelector {return v}
      return Data()
    }
    set {consistencySelector = .transaction(newValue)}
  }

  /// Starts a new transaction and reads the documents.
  /// Defaults to a read-only transaction.
  /// The new transaction ID will be returned as the first response in the
  /// stream.
  public var newTransaction: Google_Firestore_V1_TransactionOptions {
    get {
      if case .newTransaction(let v)? = consistencySelector {return v}
      return Google_Firestore_V1_TransactionOptions()
    }
    set {consistencySelector = .newTransaction(newValue)}
  }

  /// Reads documents as they were at the given time.
  /// This may not be older than 60 seconds.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = consistencySelector {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {consistencySelector = .readTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The query to run.
  public enum OneOf_QueryType: Equatable {
    /// A structured query.
    case structuredQuery(Google_Firestore_V1_StructuredQuery)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_RunQueryRequest.OneOf_QueryType, rhs: Google_Firestore_V1_RunQueryRequest.OneOf_QueryType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.structuredQuery, .structuredQuery): return {
        guard case .structuredQuery(let l) = lhs, case .structuredQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public enum OneOf_ConsistencySelector: Equatable {
    /// Reads documents in a transaction.
    case transaction(Data)
    /// Starts a new transaction and reads the documents.
    /// Defaults to a read-only transaction.
    /// The new transaction ID will be returned as the first response in the
    /// stream.
    case newTransaction(Google_Firestore_V1_TransactionOptions)
    /// Reads documents as they were at the given time.
    /// This may not be older than 60 seconds.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_RunQueryRequest.OneOf_ConsistencySelector, rhs: Google_Firestore_V1_RunQueryRequest.OneOf_ConsistencySelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.newTransaction, .newTransaction): return {
        guard case .newTransaction(let l) = lhs, case .newTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The response for [Firestore.RunQuery][google.firestore.v1.Firestore.RunQuery].
public struct Google_Firestore_V1_RunQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction that was started as part of this request.
  /// Can only be set in the first response, and only if
  /// [RunQueryRequest.new_transaction][google.firestore.v1.RunQueryRequest.new_transaction] was set in the request.
  /// If set, no other fields will be set in this response.
  public var transaction: Data = Data()

  /// A query result.
  /// Not set when reporting partial progress.
  public var document: Google_Firestore_V1_Document {
    get {return _document ?? Google_Firestore_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  /// The time at which the document was read. This may be monotonically
  /// increasing; in this case, the previous documents in the result stream are
  /// guaranteed not to have changed between their `read_time` and this one.
  ///
  /// If the query returns no results, a response with `read_time` and no
  /// `document` will be sent, and this represents the time at which the query
  /// was run.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  /// The number of results that have been skipped due to an offset between
  /// the last response and the current response.
  public var skippedResults: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _document: Google_Firestore_V1_Document? = nil
  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for [Firestore.Write][google.firestore.v1.Firestore.Write].
///
/// The first request creates a stream, or resumes an existing one from a token.
///
/// When creating a new stream, the server replies with a response containing
/// only an ID and a token, to use in the next request.
///
/// When resuming a stream, the server first streams any responses later than the
/// given token, then a response containing only an up-to-date token, to use in
/// the next request.
public struct Google_Firestore_V1_WriteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  /// This is only required in the first message.
  public var database: String = String()

  /// The ID of the write stream to resume.
  /// This may only be set in the first message. When left empty, a new write
  /// stream will be created.
  public var streamID: String = String()

  /// The writes to apply.
  ///
  /// Always executed atomically and in order.
  /// This must be empty on the first request.
  /// This may be empty on the last request.
  /// This must not be empty on all other requests.
  public var writes: [Google_Firestore_V1_Write] = []

  /// A stream token that was previously sent by the server.
  ///
  /// The client should set this field to the token from the most recent
  /// [WriteResponse][google.firestore.v1.WriteResponse] it has received. This acknowledges that the client has
  /// received responses up to this token. After sending this token, earlier
  /// tokens may not be used anymore.
  ///
  /// The server may close the stream if there are too many unacknowledged
  /// responses.
  ///
  /// Leave this field unset when creating a new stream. To resume a stream at
  /// a specific point, set this field and the `stream_id` field.
  ///
  /// Leave this field unset when creating a new stream.
  public var streamToken: Data = Data()

  /// Labels associated with this write request.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [Firestore.Write][google.firestore.v1.Firestore.Write].
public struct Google_Firestore_V1_WriteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the stream.
  /// Only set on the first message, when a new stream was created.
  public var streamID: String = String()

  /// A token that represents the position of this response in the stream.
  /// This can be used by a client to resume the stream at this point.
  ///
  /// This field is always set.
  public var streamToken: Data = Data()

  /// The result of applying the writes.
  ///
  /// This i-th write result corresponds to the i-th write in the
  /// request.
  public var writeResults: [Google_Firestore_V1_WriteResult] = []

  /// The time at which the commit occurred.
  public var commitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _commitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_commitTime = newValue}
  }
  /// Returns true if `commitTime` has been explicitly set.
  public var hasCommitTime: Bool {return self._commitTime != nil}
  /// Clears the value of `commitTime`. Subsequent reads from it will return its default value.
  public mutating func clearCommitTime() {self._commitTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A request for [Firestore.Listen][google.firestore.v1.Firestore.Listen]
public struct Google_Firestore_V1_ListenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  public var database: String = String()

  /// The supported target changes.
  public var targetChange: Google_Firestore_V1_ListenRequest.OneOf_TargetChange? = nil

  /// A target to add to this stream.
  public var addTarget: Google_Firestore_V1_Target {
    get {
      if case .addTarget(let v)? = targetChange {return v}
      return Google_Firestore_V1_Target()
    }
    set {targetChange = .addTarget(newValue)}
  }

  /// The ID of a target to remove from this stream.
  public var removeTarget: Int32 {
    get {
      if case .removeTarget(let v)? = targetChange {return v}
      return 0
    }
    set {targetChange = .removeTarget(newValue)}
  }

  /// Labels associated with this target change.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The supported target changes.
  public enum OneOf_TargetChange: Equatable {
    /// A target to add to this stream.
    case addTarget(Google_Firestore_V1_Target)
    /// The ID of a target to remove from this stream.
    case removeTarget(Int32)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_ListenRequest.OneOf_TargetChange, rhs: Google_Firestore_V1_ListenRequest.OneOf_TargetChange) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.addTarget, .addTarget): return {
        guard case .addTarget(let l) = lhs, case .addTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeTarget, .removeTarget): return {
        guard case .removeTarget(let l) = lhs, case .removeTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The response for [Firestore.Listen][google.firestore.v1.Firestore.Listen].
public struct Google_Firestore_V1_ListenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The supported responses.
  public var responseType: Google_Firestore_V1_ListenResponse.OneOf_ResponseType? = nil

  /// Targets have changed.
  public var targetChange: Google_Firestore_V1_TargetChange {
    get {
      if case .targetChange(let v)? = responseType {return v}
      return Google_Firestore_V1_TargetChange()
    }
    set {responseType = .targetChange(newValue)}
  }

  /// A [Document][google.firestore.v1.Document] has changed.
  public var documentChange: Google_Firestore_V1_DocumentChange {
    get {
      if case .documentChange(let v)? = responseType {return v}
      return Google_Firestore_V1_DocumentChange()
    }
    set {responseType = .documentChange(newValue)}
  }

  /// A [Document][google.firestore.v1.Document] has been deleted.
  public var documentDelete: Google_Firestore_V1_DocumentDelete {
    get {
      if case .documentDelete(let v)? = responseType {return v}
      return Google_Firestore_V1_DocumentDelete()
    }
    set {responseType = .documentDelete(newValue)}
  }

  /// A [Document][google.firestore.v1.Document] has been removed from a target (because it is no longer
  /// relevant to that target).
  public var documentRemove: Google_Firestore_V1_DocumentRemove {
    get {
      if case .documentRemove(let v)? = responseType {return v}
      return Google_Firestore_V1_DocumentRemove()
    }
    set {responseType = .documentRemove(newValue)}
  }

  /// A filter to apply to the set of documents previously returned for the
  /// given target.
  ///
  /// Returned when documents may have been removed from the given target, but
  /// the exact documents are unknown.
  public var filter: Google_Firestore_V1_ExistenceFilter {
    get {
      if case .filter(let v)? = responseType {return v}
      return Google_Firestore_V1_ExistenceFilter()
    }
    set {responseType = .filter(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The supported responses.
  public enum OneOf_ResponseType: Equatable {
    /// Targets have changed.
    case targetChange(Google_Firestore_V1_TargetChange)
    /// A [Document][google.firestore.v1.Document] has changed.
    case documentChange(Google_Firestore_V1_DocumentChange)
    /// A [Document][google.firestore.v1.Document] has been deleted.
    case documentDelete(Google_Firestore_V1_DocumentDelete)
    /// A [Document][google.firestore.v1.Document] has been removed from a target (because it is no longer
    /// relevant to that target).
    case documentRemove(Google_Firestore_V1_DocumentRemove)
    /// A filter to apply to the set of documents previously returned for the
    /// given target.
    ///
    /// Returned when documents may have been removed from the given target, but
    /// the exact documents are unknown.
    case filter(Google_Firestore_V1_ExistenceFilter)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_ListenResponse.OneOf_ResponseType, rhs: Google_Firestore_V1_ListenResponse.OneOf_ResponseType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.targetChange, .targetChange): return {
        guard case .targetChange(let l) = lhs, case .targetChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.documentChange, .documentChange): return {
        guard case .documentChange(let l) = lhs, case .documentChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.documentDelete, .documentDelete): return {
        guard case .documentDelete(let l) = lhs, case .documentDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.documentRemove, .documentRemove): return {
        guard case .documentRemove(let l) = lhs, case .documentRemove(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.filter, .filter): return {
        guard case .filter(let l) = lhs, case .filter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A specification of a set of documents to listen to.
public struct Google_Firestore_V1_Target {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of target to listen to.
  public var targetType: OneOf_TargetType? {
    get {return _storage._targetType}
    set {_uniqueStorage()._targetType = newValue}
  }

  /// A target specified by a query.
  public var query: Google_Firestore_V1_Target.QueryTarget {
    get {
      if case .query(let v)? = _storage._targetType {return v}
      return Google_Firestore_V1_Target.QueryTarget()
    }
    set {_uniqueStorage()._targetType = .query(newValue)}
  }

  /// A target specified by a set of document names.
  public var documents: Google_Firestore_V1_Target.DocumentsTarget {
    get {
      if case .documents(let v)? = _storage._targetType {return v}
      return Google_Firestore_V1_Target.DocumentsTarget()
    }
    set {_uniqueStorage()._targetType = .documents(newValue)}
  }

  /// When to start listening.
  ///
  /// If not specified, all matching Documents are returned before any
  /// subsequent changes.
  public var resumeType: OneOf_ResumeType? {
    get {return _storage._resumeType}
    set {_uniqueStorage()._resumeType = newValue}
  }

  /// A resume token from a prior [TargetChange][google.firestore.v1.TargetChange] for an identical target.
  ///
  /// Using a resume token with a different target is unsupported and may fail.
  public var resumeToken: Data {
    get {
      if case .resumeToken(let v)? = _storage._resumeType {return v}
      return Data()
    }
    set {_uniqueStorage()._resumeType = .resumeToken(newValue)}
  }

  /// Start listening after a specific `read_time`.
  ///
  /// The client must know the state of matching documents at this time.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = _storage._resumeType {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {_uniqueStorage()._resumeType = .readTime(newValue)}
  }

  /// A client provided target ID.
  ///
  /// If not set, the server will assign an ID for the target.
  ///
  /// Used for resuming a target without changing IDs. The IDs can either be
  /// client-assigned or be server-assigned in a previous stream. All targets
  /// with client provided IDs must be added before adding a target that needs
  /// a server-assigned id.
  public var targetID: Int32 {
    get {return _storage._targetID}
    set {_uniqueStorage()._targetID = newValue}
  }

  /// If the target should be removed once it is current and consistent.
  public var once: Bool {
    get {return _storage._once}
    set {_uniqueStorage()._once = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of target to listen to.
  public enum OneOf_TargetType: Equatable {
    /// A target specified by a query.
    case query(Google_Firestore_V1_Target.QueryTarget)
    /// A target specified by a set of document names.
    case documents(Google_Firestore_V1_Target.DocumentsTarget)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_Target.OneOf_TargetType, rhs: Google_Firestore_V1_Target.OneOf_TargetType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.query, .query): return {
        guard case .query(let l) = lhs, case .query(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.documents, .documents): return {
        guard case .documents(let l) = lhs, case .documents(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// When to start listening.
  ///
  /// If not specified, all matching Documents are returned before any
  /// subsequent changes.
  public enum OneOf_ResumeType: Equatable {
    /// A resume token from a prior [TargetChange][google.firestore.v1.TargetChange] for an identical target.
    ///
    /// Using a resume token with a different target is unsupported and may fail.
    case resumeToken(Data)
    /// Start listening after a specific `read_time`.
    ///
    /// The client must know the state of matching documents at this time.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_Target.OneOf_ResumeType, rhs: Google_Firestore_V1_Target.OneOf_ResumeType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.resumeToken, .resumeToken): return {
        guard case .resumeToken(let l) = lhs, case .resumeToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A target specified by a set of documents names.
  public struct DocumentsTarget {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The names of the documents to retrieve. In the format:
    /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
    /// The request will fail if any of the document is not a child resource of
    /// the given `database`. Duplicate names will be elided.
    public var documents: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A target specified by a query.
  public struct QueryTarget {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The parent resource name. In the format:
    /// `projects/{project_id}/databases/{database_id}/documents` or
    /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
    /// For example:
    /// `projects/my-project/databases/my-database/documents` or
    /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
    public var parent: String = String()

    /// The query to run.
    public var queryType: Google_Firestore_V1_Target.QueryTarget.OneOf_QueryType? = nil

    /// A structured query.
    public var structuredQuery: Google_Firestore_V1_StructuredQuery {
      get {
        if case .structuredQuery(let v)? = queryType {return v}
        return Google_Firestore_V1_StructuredQuery()
      }
      set {queryType = .structuredQuery(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The query to run.
    public enum OneOf_QueryType: Equatable {
      /// A structured query.
      case structuredQuery(Google_Firestore_V1_StructuredQuery)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_V1_Target.QueryTarget.OneOf_QueryType, rhs: Google_Firestore_V1_Target.QueryTarget.OneOf_QueryType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.structuredQuery, .structuredQuery): return {
          guard case .structuredQuery(let l) = lhs, case .structuredQuery(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Targets being watched have changed.
public struct Google_Firestore_V1_TargetChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of change that occurred.
  public var targetChangeType: Google_Firestore_V1_TargetChange.TargetChangeType = .noChange

  /// The target IDs of targets that have changed.
  ///
  /// If empty, the change applies to all targets.
  ///
  /// For `target_change_type=ADD`, the order of the target IDs matches the order
  /// of the requests to add the targets. This allows clients to unambiguously
  /// associate server-assigned target IDs with added targets.
  ///
  /// For other states, the order of the target IDs is not defined.
  public var targetIds: [Int32] = []

  /// The error that resulted in this change, if applicable.
  public var cause: Google_Rpc_Status {
    get {return _cause ?? Google_Rpc_Status()}
    set {_cause = newValue}
  }
  /// Returns true if `cause` has been explicitly set.
  public var hasCause: Bool {return self._cause != nil}
  /// Clears the value of `cause`. Subsequent reads from it will return its default value.
  public mutating func clearCause() {self._cause = nil}

  /// A token that can be used to resume the stream for the given `target_ids`,
  /// or all targets if `target_ids` is empty.
  ///
  /// Not set on every target change.
  public var resumeToken: Data = Data()

  /// The consistent `read_time` for the given `target_ids` (omitted when the
  /// target_ids are not at a consistent snapshot).
  ///
  /// The stream is guaranteed to send a `read_time` with `target_ids` empty
  /// whenever the entire stream reaches a new consistent snapshot. ADD,
  /// CURRENT, and RESET messages are guaranteed to (eventually) result in a
  /// new consistent snapshot (while NO_CHANGE and REMOVE messages are not).
  ///
  /// For a given stream, `read_time` is guaranteed to be monotonically
  /// increasing.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of change.
  public enum TargetChangeType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No change has occurred. Used only to send an updated `resume_token`.
    case noChange // = 0

    /// The targets have been added.
    case add // = 1

    /// The targets have been removed.
    case remove // = 2

    /// The targets reflect all changes committed before the targets were added
    /// to the stream.
    ///
    /// This will be sent after or with a `read_time` that is greater than or
    /// equal to the time at which the targets were added.
    ///
    /// Listeners can wait for this change if read-after-write semantics
    /// are desired.
    case current // = 3

    /// The targets have been reset, and a new initial state for the targets
    /// will be returned in subsequent changes.
    ///
    /// After the initial state is complete, `CURRENT` will be returned even
    /// if the target was previously indicated to be `CURRENT`.
    case reset // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .noChange
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noChange
      case 1: self = .add
      case 2: self = .remove
      case 3: self = .current
      case 4: self = .reset
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .noChange: return 0
      case .add: return 1
      case .remove: return 2
      case .current: return 3
      case .reset: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _cause: Google_Rpc_Status? = nil
  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Firestore_V1_TargetChange.TargetChangeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_V1_TargetChange.TargetChangeType] = [
    .noChange,
    .add,
    .remove,
    .current,
    .reset,
  ]
}

#endif  // swift(>=4.2)

/// The request for [Firestore.ListCollectionIds][google.firestore.v1.Firestore.ListCollectionIds].
public struct Google_Firestore_V1_ListCollectionIdsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent document. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  /// For example:
  /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
  public var parent: String = String()

  /// The maximum number of results to return.
  public var pageSize: Int32 = 0

  /// A page token. Must be a value from
  /// [ListCollectionIdsResponse][google.firestore.v1.ListCollectionIdsResponse].
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response from [Firestore.ListCollectionIds][google.firestore.v1.Firestore.ListCollectionIds].
public struct Google_Firestore_V1_ListCollectionIdsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection ids.
  public var collectionIds: [String] = []

  /// A page token that may be used to continue the list.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.firestore.v1"

extension Google_Firestore_V1_GetDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "mask"),
    3: .same(proto: "transaction"),
    5: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mask) }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.consistencySelector != nil {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .transaction(v)
        }
      }()
      case 5: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .readTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .readTime(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._mask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.consistencySelector {
    case .transaction?: try {
      guard case .transaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .readTime?: try {
      guard case .readTime(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_GetDocumentRequest, rhs: Google_Firestore_V1_GetDocumentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs.consistencySelector != rhs.consistencySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ListDocumentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDocumentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "collection_id"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    6: .standard(proto: "order_by"),
    7: .same(proto: "mask"),
    8: .same(proto: "transaction"),
    10: .standard(proto: "read_time"),
    12: .standard(proto: "show_missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.collectionID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._mask) }()
      case 8: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.consistencySelector != nil {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .transaction(v)
        }
      }()
      case 10: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .readTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .readTime(v)
        }
      }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.showMissing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.collectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionID, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 6)
    }
    try { if let v = self._mask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    switch self.consistencySelector {
    case .transaction?: try {
      guard case .transaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }()
    case .readTime?: try {
      guard case .readTime(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    if self.showMissing != false {
      try visitor.visitSingularBoolField(value: self.showMissing, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListDocumentsRequest, rhs: Google_Firestore_V1_ListDocumentsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.collectionID != rhs.collectionID {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs.consistencySelector != rhs.consistencySelector {return false}
    if lhs.showMissing != rhs.showMissing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ListDocumentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDocumentsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "documents"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.documents) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.documents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.documents, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListDocumentsResponse, rhs: Google_Firestore_V1_ListDocumentsResponse) -> Bool {
    if lhs.documents != rhs.documents {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_CreateDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "collection_id"),
    3: .standard(proto: "document_id"),
    4: .same(proto: "document"),
    5: .same(proto: "mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.collectionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.documentID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._mask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.collectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionID, fieldNumber: 2)
    }
    if !self.documentID.isEmpty {
      try visitor.visitSingularStringField(value: self.documentID, fieldNumber: 3)
    }
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._mask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_CreateDocumentRequest, rhs: Google_Firestore_V1_CreateDocumentRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.collectionID != rhs.collectionID {return false}
    if lhs.documentID != rhs.documentID {return false}
    if lhs._document != rhs._document {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_UpdateDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    2: .standard(proto: "update_mask"),
    3: .same(proto: "mask"),
    4: .standard(proto: "current_document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mask) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._currentDocument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._currentDocument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_UpdateDocumentRequest, rhs: Google_Firestore_V1_UpdateDocumentRequest) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs._currentDocument != rhs._currentDocument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_DeleteDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "current_document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._currentDocument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._currentDocument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_DeleteDocumentRequest, rhs: Google_Firestore_V1_DeleteDocumentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._currentDocument != rhs._currentDocument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_BatchGetDocumentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchGetDocumentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "documents"),
    3: .same(proto: "mask"),
    4: .same(proto: "transaction"),
    5: .standard(proto: "new_transaction"),
    7: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.documents) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mask) }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.consistencySelector != nil {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .transaction(v)
        }
      }()
      case 5: try {
        var v: Google_Firestore_V1_TransactionOptions?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .newTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .newTransaction(v)
        }
      }()
      case 7: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .readTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .readTime(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if !self.documents.isEmpty {
      try visitor.visitRepeatedStringField(value: self.documents, fieldNumber: 2)
    }
    try { if let v = self._mask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    switch self.consistencySelector {
    case .transaction?: try {
      guard case .transaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .newTransaction?: try {
      guard case .newTransaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .readTime?: try {
      guard case .readTime(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_BatchGetDocumentsRequest, rhs: Google_Firestore_V1_BatchGetDocumentsRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.documents != rhs.documents {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs.consistencySelector != rhs.consistencySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_BatchGetDocumentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchGetDocumentsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
    3: .same(proto: "transaction"),
    4: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_V1_Document?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .found(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .missing(v)
        }
      }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .found?: try {
      guard case .found(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 3)
    }
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_BatchGetDocumentsResponse, rhs: Google_Firestore_V1_BatchGetDocumentsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_BeginTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BeginTransactionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_BeginTransactionRequest, rhs: Google_Firestore_V1_BeginTransactionRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_BeginTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BeginTransactionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_BeginTransactionResponse, rhs: Google_Firestore_V1_BeginTransactionResponse) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_CommitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "writes"),
    3: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.writes) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if !self.writes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writes, fieldNumber: 2)
    }
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_CommitRequest, rhs: Google_Firestore_V1_CommitRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.writes != rhs.writes {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_CommitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "write_results"),
    2: .standard(proto: "commit_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.writeResults) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._commitTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.writeResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writeResults, fieldNumber: 1)
    }
    try { if let v = self._commitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_CommitResponse, rhs: Google_Firestore_V1_CommitResponse) -> Bool {
    if lhs.writeResults != rhs.writeResults {return false}
    if lhs._commitTime != rhs._commitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_RollbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollbackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_RollbackRequest, rhs: Google_Firestore_V1_RollbackRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_RunQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "structured_query"),
    5: .same(proto: "transaction"),
    6: .standard(proto: "new_transaction"),
    7: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: Google_Firestore_V1_StructuredQuery?
        var hadOneofValue = false
        if let current = self.queryType {
          hadOneofValue = true
          if case .structuredQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.queryType = .structuredQuery(v)
        }
      }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.consistencySelector != nil {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .transaction(v)
        }
      }()
      case 6: try {
        var v: Google_Firestore_V1_TransactionOptions?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .newTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .newTransaction(v)
        }
      }()
      case 7: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .readTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .readTime(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if case .structuredQuery(let v)? = self.queryType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.consistencySelector {
    case .transaction?: try {
      guard case .transaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case .newTransaction?: try {
      guard case .newTransaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .readTime?: try {
      guard case .readTime(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_RunQueryRequest, rhs: Google_Firestore_V1_RunQueryRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.queryType != rhs.queryType {return false}
    if lhs.consistencySelector != rhs.consistencySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_RunQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "transaction"),
    1: .same(proto: "document"),
    3: .standard(proto: "read_time"),
    4: .standard(proto: "skipped_results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.skippedResults) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 2)
    }
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.skippedResults != 0 {
      try visitor.visitSingularInt32Field(value: self.skippedResults, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_RunQueryResponse, rhs: Google_Firestore_V1_RunQueryResponse) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs._document != rhs._document {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.skippedResults != rhs.skippedResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_WriteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .standard(proto: "stream_id"),
    3: .same(proto: "writes"),
    4: .standard(proto: "stream_token"),
    5: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.writes) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.streamToken) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 2)
    }
    if !self.writes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writes, fieldNumber: 3)
    }
    if !self.streamToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.streamToken, fieldNumber: 4)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_WriteRequest, rhs: Google_Firestore_V1_WriteRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs.writes != rhs.writes {return false}
    if lhs.streamToken != rhs.streamToken {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_WriteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id"),
    2: .standard(proto: "stream_token"),
    3: .standard(proto: "write_results"),
    4: .standard(proto: "commit_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.streamToken) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.writeResults) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._commitTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if !self.streamToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.streamToken, fieldNumber: 2)
    }
    if !self.writeResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writeResults, fieldNumber: 3)
    }
    try { if let v = self._commitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_WriteResponse, rhs: Google_Firestore_V1_WriteResponse) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.streamToken != rhs.streamToken {return false}
    if lhs.writeResults != rhs.writeResults {return false}
    if lhs._commitTime != rhs._commitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ListenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListenRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .standard(proto: "add_target"),
    3: .standard(proto: "remove_target"),
    4: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try {
        var v: Google_Firestore_V1_Target?
        var hadOneofValue = false
        if let current = self.targetChange {
          hadOneofValue = true
          if case .addTarget(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.targetChange = .addTarget(v)
        }
      }()
      case 3: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.targetChange != nil {try decoder.handleConflictingOneOf()}
          self.targetChange = .removeTarget(v)
        }
      }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    switch self.targetChange {
    case .addTarget?: try {
      guard case .addTarget(let v)? = self.targetChange else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .removeTarget?: try {
      guard case .removeTarget(let v)? = self.targetChange else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListenRequest, rhs: Google_Firestore_V1_ListenRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.targetChange != rhs.targetChange {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ListenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListenResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "target_change"),
    3: .standard(proto: "document_change"),
    4: .standard(proto: "document_delete"),
    6: .standard(proto: "document_remove"),
    5: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Firestore_V1_TargetChange?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .targetChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .targetChange(v)
        }
      }()
      case 3: try {
        var v: Google_Firestore_V1_DocumentChange?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .documentChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .documentChange(v)
        }
      }()
      case 4: try {
        var v: Google_Firestore_V1_DocumentDelete?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .documentDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .documentDelete(v)
        }
      }()
      case 5: try {
        var v: Google_Firestore_V1_ExistenceFilter?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .filter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .filter(v)
        }
      }()
      case 6: try {
        var v: Google_Firestore_V1_DocumentRemove?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .documentRemove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .documentRemove(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.responseType {
    case .targetChange?: try {
      guard case .targetChange(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .documentChange?: try {
      guard case .documentChange(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .documentDelete?: try {
      guard case .documentDelete(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .filter?: try {
      guard case .filter(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .documentRemove?: try {
      guard case .documentRemove(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListenResponse, rhs: Google_Firestore_V1_ListenResponse) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Target: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Target"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "query"),
    3: .same(proto: "documents"),
    4: .standard(proto: "resume_token"),
    11: .standard(proto: "read_time"),
    5: .standard(proto: "target_id"),
    6: .same(proto: "once"),
  ]

  fileprivate class _StorageClass {
    var _targetType: Google_Firestore_V1_Target.OneOf_TargetType?
    var _resumeType: Google_Firestore_V1_Target.OneOf_ResumeType?
    var _targetID: Int32 = 0
    var _once: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetType = source._targetType
      _resumeType = source._resumeType
      _targetID = source._targetID
      _once = source._once
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try {
          var v: Google_Firestore_V1_Target.QueryTarget?
          var hadOneofValue = false
          if let current = _storage._targetType {
            hadOneofValue = true
            if case .query(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._targetType = .query(v)
          }
        }()
        case 3: try {
          var v: Google_Firestore_V1_Target.DocumentsTarget?
          var hadOneofValue = false
          if let current = _storage._targetType {
            hadOneofValue = true
            if case .documents(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._targetType = .documents(v)
          }
        }()
        case 4: try {
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {
            if _storage._resumeType != nil {try decoder.handleConflictingOneOf()}
            _storage._resumeType = .resumeToken(v)
          }
        }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._targetID) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._once) }()
        case 11: try {
          var v: SwiftProtobuf.Google_Protobuf_Timestamp?
          var hadOneofValue = false
          if let current = _storage._resumeType {
            hadOneofValue = true
            if case .readTime(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resumeType = .readTime(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._targetType {
      case .query?: try {
        guard case .query(let v)? = _storage._targetType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .documents?: try {
        guard case .documents(let v)? = _storage._targetType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case nil: break
      }
      try { if case .resumeToken(let v)? = _storage._resumeType {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      } }()
      if _storage._targetID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._targetID, fieldNumber: 5)
      }
      if _storage._once != false {
        try visitor.visitSingularBoolField(value: _storage._once, fieldNumber: 6)
      }
      try { if case .readTime(let v)? = _storage._resumeType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_Target, rhs: Google_Firestore_V1_Target) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetType != rhs_storage._targetType {return false}
        if _storage._resumeType != rhs_storage._resumeType {return false}
        if _storage._targetID != rhs_storage._targetID {return false}
        if _storage._once != rhs_storage._once {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Target.DocumentsTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_Target.protoMessageName + ".DocumentsTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "documents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.documents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.documents.isEmpty {
      try visitor.visitRepeatedStringField(value: self.documents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_Target.DocumentsTarget, rhs: Google_Firestore_V1_Target.DocumentsTarget) -> Bool {
    if lhs.documents != rhs.documents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Target.QueryTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_Target.protoMessageName + ".QueryTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "structured_query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: Google_Firestore_V1_StructuredQuery?
        var hadOneofValue = false
        if let current = self.queryType {
          hadOneofValue = true
          if case .structuredQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.queryType = .structuredQuery(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if case .structuredQuery(let v)? = self.queryType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_Target.QueryTarget, rhs: Google_Firestore_V1_Target.QueryTarget) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.queryType != rhs.queryType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_TargetChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetChange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_change_type"),
    2: .standard(proto: "target_ids"),
    3: .same(proto: "cause"),
    4: .standard(proto: "resume_token"),
    6: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.targetChangeType) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.targetIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cause) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.resumeToken) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.targetChangeType != .noChange {
      try visitor.visitSingularEnumField(value: self.targetChangeType, fieldNumber: 1)
    }
    if !self.targetIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.targetIds, fieldNumber: 2)
    }
    try { if let v = self._cause {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.resumeToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.resumeToken, fieldNumber: 4)
    }
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_TargetChange, rhs: Google_Firestore_V1_TargetChange) -> Bool {
    if lhs.targetChangeType != rhs.targetChangeType {return false}
    if lhs.targetIds != rhs.targetIds {return false}
    if lhs._cause != rhs._cause {return false}
    if lhs.resumeToken != rhs.resumeToken {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_TargetChange.TargetChangeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_CHANGE"),
    1: .same(proto: "ADD"),
    2: .same(proto: "REMOVE"),
    3: .same(proto: "CURRENT"),
    4: .same(proto: "RESET"),
  ]
}

extension Google_Firestore_V1_ListCollectionIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCollectionIdsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListCollectionIdsRequest, rhs: Google_Firestore_V1_ListCollectionIdsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ListCollectionIdsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCollectionIdsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collection_ids"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.collectionIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collectionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.collectionIds, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListCollectionIdsResponse, rhs: Google_Firestore_V1_ListCollectionIdsResponse) -> Bool {
    if lhs.collectionIds != rhs.collectionIds {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
